#!/bin/bash	

#############################################################################
#
# CONFIG FUNCTIONS
#
#

SOURCE_DIR=$(dirname "$BASH_SOURCE[0]")

# config_files emits names of the config files
config_files() {
	local exclude_regex="$1"
	# end of params

	for f in $SOURCE_DIR/config/fl_*; do
		[[ $exclude_regex && $f =~ $exclude_regex ]] || echo "$f"
	done
}

# source includes
if [ -d "$SOURCE_DIR/config" ]; then
	for f in $(config_files); do
		. "$f"
	done
fi


#############################################################################
#
# GLOBALS
#
#

# fl.sh ssh destinations
FL_SSH=($MGMT_SSH $SCE_CLI_SSH $L4S_CLI_SSH)

# clients
CLIENTS_SSH=($SCE_CLI_SSH $L4S_CLI_SSH)

# push config
PUSH_RSYNC_DEST="$PUSH_SSH_DEST:$ARCHIVE_DIR"


#############################################################################
#
# PLOT FUNCTIONS
#
#

# plot_tattr emits a title attribute
plot_tattr() {
	local key="$1"
	local tattrs=($2)
	# end of params

	for a in "${tattrs[@]}"; do
		IFS=":" read k v <<< "$a"
		if [ "$key" == "$k" ]; then
			echo "$v"
			return 0
		fi
	done
}

# plot_rtt_scale emits the plot's RTT scale from the base RTT
plot_rtt_scale() {
	case $1 in
		20ms) echo "20,70" ;;
		10ms) echo "10,60" ;;
		80ms) echo "80,150" ;;
		160ms) echo "160,260" ;;
		500ms) echo "500,1000" ;;
		*) echo "0,200" ;;
	esac
}

# plot_bandwidth_scale emits the plot's bandwidth scale from the bandwidth
plot_bandwidth_scale() {
	case $1 in
		1Mbit) echo "0,1.2" ;;
		5Mbit) echo "0,6" ;;
		10Mbit) echo "0,12" ;;
		25Mbit) echo "0,30" ;;
		50Mbit) echo "0,55" ;;
		250Mbit) echo "0,260" ;;
		*) echo "0,1000" ;;
	esac
}

# plot_cc_algo_title emits the title of a CC algo from its key string
plot_cc_algo_title() {
	case $1 in
		cubic) echo "CUBIC" ;;
		cubic-sce) echo "CUBIC-SCE" ;;
		reno) echo "Reno" ;;
		reno-sce) echo "Reno-SCE" ;;
		dctcp) echo "DCTCP" ;;
		dctcp-sce) echo "DCTCP-SCE" ;;
		prague) echo "Prague" ;;
		bbr) echo "BBR" ;;
		*) echo "UnknownCC" ;;
	esac
}

plot_vs_title() {
	case $1 in
		cubic-vs-cubic-sce) echo "CUBIC vs CUBIC-SCE" ;;
		cubic-vs-prague) echo "CUBIC vs Prague" ;;
		bbr-vs-cubic-sce) echo "BBR vs CUBIC-SCE" ;;
		bbr-vs-prague) echo "BBR vs Prague" ;;
		*) echo "UnknownVS" ;;
	esac
}

# plot_arch_title emits the title of the architecture from its key string
plot_arch_title() {
	case $1 in
		sce) echo "SCE" ;;
		l4s) echo "L4S" ;;
		*) echo "UnknownArch" ;;
	esac
}

# plot_qdisc_title emits the qdisc title from its key string
plot_qdisc_title() {
	case $1 in
		*cake*) echo "Cake FQ" ;;
		*cnq_codel_af*) echo "CNQ-CodelAF" ;;
		*twin_codel_af*) echo "Twin-CodelAF" ;;
		*lfq_cobalt*) echo "LFQ-COBALT" ;;
		*dualpi2*) echo "DualPI2" ;;
		*pie*) echo "PIE" ;;
		*) echo "$1" ;;
	esac
}

# plot_file generates one plot
plot_file() {
	local arch="$1"
	local in="$2"
	local plot="$3"
	local visitor=$4
	# end of params

	# jq_test_param emits a test parameter value from a .flent.gz file
	jq_test_param() {
		gzip -dc $in | jq -r ".metadata.TEST_PARAMETERS.$1"
	}
	
	# jq_title emits the metadata title from a .flent.gz file
	jq_title() {
		gzip -dc $in | jq -r ".metadata.TITLE"
	}
	
	# jq_batch_name emits the metadata batch name from a .flent.gz file
	jq_batch_name() {
		gzip -dc $in | jq -r ".metadata.BATCH_NAME"
	}

	# jq_scale_rtt emits the max RTT Y value calculated from the data values
	jq_scale_rtt() {
		gzip -dc "$in" | \
			jq "(.results.\"Ping (ms) ICMP\"+.results.\"TCP upload::tcp_rtt\"|max-$rttval)*3+$rttval"
	}

	# read params from flent file
	local cc_algo=$(jq_test_param cc_algo)
	local cc_algos=$(jq_test_param cc_algos)
	local subtitle=$(jq_title)
	local batch_name=$(jq_batch_name)
	local rtt=$(plot_tattr rtt "$subtitle")
	local rttval=${rtt//[!0-9]/}
	local bandwidth=$(plot_tattr bandwidth "$subtitle")
	local vs=$(plot_tattr vs "$subtitle")
	local qdisc=$(plot_tattr qdisc "$subtitle")

	# output path
	local outdir=$(dirname "$in")
	local outfile=$(basename "$in")
	outfile="${outfile#"batch-"}"
	outfile="${outfile%".flent.gz"}"
	outfile+="_$plot"
	local outpath="$outdir/$outfile.$PLOT_FORMAT"

	# further calculated params
	local rtt_scale=$(plot_rtt_scale $rtt)
	local bandwidth_scale=$(plot_bandwidth_scale $bandwidth)
	local cc_title=$(plot_cc_algo_title $cc_algo)
	local arch_title=$(plot_arch_title $arch)
	local vs_title=$(plot_vs_title $vs)
	local colors
	[[ $COLORS ]] && colors="--colours $COLORS"

	# visitor assigned params
	local title
	local subtitle2

	# other locals
	local tput_name
	local tput_abbrev
	local tput_title
	if [[ $plot =~ delivery ]]; then
		tput_name="delivery rate"
		tput_abbrev="delivery"
		tput_title="Delivery Rate"
	else 
		tput_name="throughput"
		tput_abbrev="thruput"
		tput_title="Throughput"
	fi

	# start empty array for arguments
	local fl_args=()

	# visitor assigns title and additional arguments
	$visitor

	# common args
	fl_args+=( "-i" "$in" )
	fl_args+=( "-p" "$plot" )
	fl_args+=( "-o" "$outpath" )
	fl_args+=( "--figure-width" "$PLOT_WIDTH" )
	fl_args+=( "--figure-height" "$PLOT_HEIGHT" )
	[[ $colors ]] && fl_args+=("--colours" "$colors" )
	fl_args+=( "--fallback-layout" )

	# plot-specific args
	case $plot in
		tcp_delivery_with_rtt)
			fl_args+=( "--bounds-y" "$bandwidth_scale" )
			fl_args+=( "--bounds-y" "$rtt_scale" )
			fl_args+=( "--label-y" "Mbps" )
			fl_args+=( "--label-y" "ms" )
			;;
	esac

	local final_title=$(printf "%s\n\n%s" "$title" "$subtitle")
	if [[ $subtitle2 ]]; then
		final_title=$(printf "%s\n%s" "$final_title" "$subtitle2")
	fi

	fl_args+=( "--override-title" "$final_title" )

	flent "${fl_args[@]}"
}

# s1_visitor is the plot visitor for scenario 1
s1_visitor() {
	title="$arch_title: Single Flow $cc_title"

	fl_args+=( "--override-label" "$cc_algo $tput_name" )
	fl_args+=( "--override-label" "ICMP RTT" )
	fl_args+=( "--override-label" "TCP RTT" )
}

# s2_visitor is the plot visitor for scenario 2
s2_visitor() {
	local IFS=,
	local cca

	if [[ $qdisc =~ (^pfifo|pie\(noecn\)) ]]; then
		rtt_scale="$rttval,$(jq_scale_rtt)"
	fi

	fl_args+=( "--override-label" "" )
	fl_args+=( "--override-label" "" )

	for cca in $cc_algos; do
		fl_args+=( "--override-label" "$(plot_cc_algo_title $cca) $tput_name" )
	done

	fl_args+=( "--override-label" "ICMP RTT" )

	fl_args+=( "--override-label" "" )
	fl_args+=( "--override-label" "" )

	for cca in $cc_algos; do
		fl_args+=( "--override-label" "$(plot_cc_algo_title $cca) TCP RTT" )
	done

	title="$arch_title: $(plot_qdisc_title $qdisc), $vs_title"
}

# s3_visitor is the plot visitor for scenario 3
s3_visitor() {
	title="$arch_title: Bottleneck Shift for $cc_title"

	fl_args+=( "--override-label" "$cc_algo $tput_name" )
	fl_args+=( "--override-label" "ICMP RTT" )
	fl_args+=( "--override-label" "TCP RTT" )
}

# s4_visitor is the plot visitor for scenario 4
s4_visitor() {
	title="$arch_title: Capacity Reduction for $cc_title"

	fl_args+=( "--override-label" "$cc_algo $tput_name" )
	fl_args+=( "--override-label" "ICMP RTT" )
	fl_args+=( "--override-label" "TCP RTT" )
}

# s5_visitor is the plot visitor for scenario 5
s5_visitor() {
	title="$arch_title: WiFi Burstiness with $cc_title"

	fl_args+=( "--override-label" "$cc_algo $tput_name" )
	fl_args+=( "--override-label" "ICMP RTT" )
	fl_args+=( "--override-label" "TCP RTT" )
}

# s6_visitor is the plot visitor for scenario 6
s6_visitor() {
	title="$arch_title: Jitter with $cc_title"

	fl_args+=( "--override-label" "$cc_algo $tput_name" )
	fl_args+=( "--override-label" "ICMP RTT" )
	fl_args+=( "--override-label" "TCP RTT" )
}

#s2_visitor_bar_combine() {
#	local IFS=,
#
#	for cca in $cc_algos; do
#		fl_args+=( "--override-label" "$(plot_cc_algo_title $cca)" )
#	done
#
#	fl_args+=( "--label-y" "Mbps" )
#	fl_args+=( "--no-labels" )
#
#	title+="$cc_mix_title"
#	title+=" Competition w/$(plot_queue_title $queue),"
#	case $rtt in
#		20ms) title+=" 60 Second Mean" ;;
#		160ms) title+=" 120 Second Mean" ;;
#	esac
#	title+=" $tput_title"
#}
#
#s2_visitor_tcp_delivery_with_rtt() {
#	local IFS=,
#	local cca
#
#	fl_args+=( "--override-label" "" )
#	fl_args+=( "--override-label" "" )
#
#	for cca in $cc_algos; do
#		fl_args+=( "--override-label" "$(plot_cc_algo_title $cca) $tput_name" )
#	done
#
#	fl_args+=( "--override-label" "ICMP RTT" )
#
#	fl_args+=( "--override-label" "" )
#	fl_args+=( "--override-label" "" )
#
#	for cca in $cc_algos; do
#		fl_args+=( "--override-label" "$(plot_cc_algo_title $cca) TCP RTT" )
#	done
#
#	title+="$cc_mix_title"
#	title+=" Competition w/$(plot_queue_title $queue),"
#	title+=" $tput_title"
#}
#
#remote_plot $DIR/s2-fiveflow \
#	bar_combine s2_visitor_bar_combine \
#	tcp_delivery_with_rtt s2_visitor_tcp_delivery_with_rtt


#############################################################################
#
# UTILITY FUNCTIONS
#
#

# fl_ssh runs fl remotely via ssh
fl_ssh() {
	local dest=$1; shift # ssh destination
	local root=$1; shift # true|false
	local background=$1; shift # true|false
	local args="$@"
	# end of params

	local sudo_args
	[[ $root == true ]] && sudo_args='$([[ $EUID != 0 ]] && echo sudo)'

	local args_esc
	args_esc=$(printf %q "$args")

	# run directly on hosts with fl script, or via stdout on hosts without
	if array_contains $dest "${FL_SSH[@]}"; then
		if [[ $background == true ]]; then
			ssh $dest cd $SCRIPT_DIR\; nohup $sudo_args ./fl $args_esc \&\>log.txt \&
		else
			ssh $dest cd $SCRIPT_DIR\; $sudo_args ./fl $args_esc 2>&1 | \
				sed "s/^/$dest: /"
			return ${PIPESTATUS[0]}
		fi
	else
		if [[ $background == true ]]; then
			cat $(config_files "local") fl | \
				ssh $dest $sudo_args nohup bash -s $args_esc \&\> \
					\$\(mktemp /tmp/fl.log.XXXXXXXX\) \&
		else
			cat $(config_files "local") fl | \
				ssh $dest $sudo_args bash -s $args_esc || return $?
		fi
	fi
}

# fl_node runs fl either via netns or remotely via ssh
fl_node() {
	local arch=$1; shift
	local net=$1; shift
	local node=$1; shift
	local args="$@"
	# end of params

	case $net in
	phys)
		fl_ssh $(node_ssh $arch $node) true false $args || return $?
		;;
	ns)
		nsx $node ./fl $args || return $?
		;;
	*)
		>&2 echo "unknown net: $net"
		return 1
	esac
}

# fl_node_pull copies files from a node's directory to a local directory
fl_node_pull() {
	local arch=$1
	local net=$2
	local node=$3
	local src_dir="$4"
	local dst_dir="$5"
	# end of params

	case $net in
	phys)
		ev scp \"$(node_ssh $arch $node):$src_dir/*\" "$dst_dir" || return $?
		;;
	ns)
		ev cp "$src_dir/*" "$dst_dir" || return $?
		;;
	*)
		>&2 echo "unknown net: $net"
		return 1
	esac
}

# send_pushover sends a pushover message
send_pushover() {
	local sound="$1"
	local msg="$2"
	# end of params

	if [[ $PUSHOVER_USER ]]; then
		response=$(/usr/bin/curl -s \
			--retry 3 \
			--form-string token=$PUSHOVER_TOKEN \
			--form-string user=$PUSHOVER_USER \
			--form-string "sound=$sound" \
			--form-string "message=$msg" \
			https://api.pushover.net/1/messages.json)

		[[ ! "$response" == *"\"status\":1"* ]] && echo "$response" >&2
	fi
}

# set_offloads enables or disables offloads for an eth iface
set_offloads() {
	local iface="$1"
	local state="$2" # on|off
	local ns="$3"
	# end of params

	local cmd
	cmd="sudo"
	[[ $ns ]] && cmd+=" ip netns exec $ns"
	cmd+=" ethtool -K $iface"
	cmd+=" rx $state tx $state"
	cmd+=" sg $state tso $state"
	cmd+=" gso $state gro $state"
	cmd+=" rxvlan $state txvlan $state"

	$cmd
}

# wait_for_pids waits for processes to exit and returns a count of failures
wait_for_pids() {
	local pids=("$@")
	# end of params

	local errs=0
	local p
	for p in ${pids[@]}; do
		wait $p || ((errs++))
	done
	return $errs
}

# array_contains succeeds if an array contains an element
array_contains() {
	local elem="$1"; shift
	local arr=("$@")
	# end of params

	local e
	for e in "${arr[@]}"; do
		[[ $e == $elem ]] && return 0
	done
	return 1
}

# ifb emits the ifb interface name for an interface
ifb() {
	local iface=$1
	echo "ifb4$iface"
}

# ev emits and evaluates a command
ev() {
	local r=0
	echo "+ $@"
	eval "$@"
	r=$?
	if [[ $DEBUG == 1 && $r != 0 ]]; then
		>&2 echo "command failed with status $r: $@"
	fi
	echo
	return $r
}

# evs runs eval separately for each command separated by ;
evs() {
	IFS=';' read -r -a cmds <<< "$@"
	local c
	local r

	for c in "${cmds[@]}"; do
		# remove leading and trailing whitespace
		c=$(echo $c | awk '{$1=$1};1')
		eval $c
		r=$?
		if (( r != 0 )); then
			>&2 echo "command failed with status $r: $c"
			return $r
		fi
	done
}

# ev evaluates a command and only emits it if DEBUG is 1
evq() {
	local r
	[[ $DEBUG == 1 ]] && echo "+ $@"
	eval "$@" &>/dev/null
	r=$?
	if [[ $DEBUG == 1 && $r != 0 ]]; then
		>&2 echo "command failed with status $r: $@"
	fi
	return $r
}

# split splits a string by comma
split() {
	local s=(${1//,/ })
	echo "${s[@]}"
}


#############################################################################
#
# NAMESPACES FUNCTIONS
#
#

# nsx executes a command in a namespace
nsx() {
	local ns="$1"; shift
	local args="$@"
	# end of fixed args

	# client is run in default namespace
	if [[ $ns == cli ]]; then
		$args
	else
		sudo ip netns exec $ns $args
	fi
}

# ns_setup sets up the netns environment
ns_setup() {
	local arch=$1
	# end of params

	# srv
	sudo ip netns add srv || return $?
	sudo ip link add dev $NS_SRV_LEFT type veth peer name $NS_MID_RIGHT || return $?
	sudo ip link set dev $NS_SRV_LEFT netns srv || return $?
	nsx srv ip addr add $NS_SRV_IP dev $NS_SRV_LEFT || return $?
	nsx srv ip link set $NS_SRV_LEFT up || return $?
	if [[ $NS_OFFLOADS == off ]]; then
		set_offloads $NS_SRV_LEFT off srv || return $?
	fi
	if [[ $arch == "sce" ]]; then
		nsx srv sysctl -qw net.ipv4.tcp_sce=1 || return $?
		nsx srv sysctl -qw net.ipv4.tcp_ecn=1 || return $?
	elif [[ $arch == "l4s" ]]; then
		nsx srv sysctl -qw net.ipv4.tcp_ecn=3 || return $?
	fi

	# mid
	sudo ip netns add mid || return $?
	sudo ip link set dev $NS_MID_RIGHT netns mid || return $?
	if [[ $NS_OFFLOADS == off ]]; then
		set_offloads $NS_MID_RIGHT off mid || return $?
	fi
	nsx mid ip link set $NS_MID_RIGHT up || return $?
	sudo ip link add dev $NS_MID_LEFT type veth peer name $NS_CLI_RIGHT || return $?
	sudo ip link set dev $NS_MID_LEFT netns mid || return $?
	if [[ $NS_OFFLOADS == off ]]; then
		set_offloads $NS_MID_LEFT off mid || return $?
	fi
	nsx mid ip link set $NS_MID_LEFT up || return $?
	nsx mid ip link add name mid.b type bridge || return $?
	nsx mid ip link set dev $NS_MID_RIGHT master mid.b || return $?
	nsx mid ip link set dev $NS_MID_LEFT master mid.b || return $?
	nsx mid ip link set dev mid.b up || return $?

	# cli uses default namespace
	sudo ip addr add $NS_CLI_IP dev $NS_CLI_RIGHT || return $?
	sudo ip link set $NS_CLI_RIGHT up || return $?
	if [[ $NS_OFFLOADS == off ]]; then
		set_offloads $NS_CLI_RIGHT off || return $?
	fi
	if [[ $arch == "sce" ]]; then
		sudo sysctl -qw net.ipv4.tcp_sce=1 || return $? >/dev/null
		sudo sysctl -qw net.ipv4.tcp_ecn=1 || return $? >/dev/null
	elif [[ $arch == "l4s" ]]; then
		sudo sysctl -qw net.ipv4.tcp_ecn=3 || return $? >/dev/null
	fi

	# start netserver (with -d for debug so it doesn't change perms on /dev/null)
	if ! command -v netserver >&/dev/null; then
		>&2 echo "netserver not found"
		return 1
	fi
	nsx srv netserver -d >&/dev/null

	# start irtt
	if ! command -v irtt >&/dev/null; then
		>&2 echo "irtt not found"
		return 1
	fi
	nsx srv irtt server -i 0 --syslog=local: >&/dev/null &
}

# ns_teardown tears down the netns environment
ns_teardown() {
	# stop services
	sudo pkill irtt || true
	sudo pkill netserver || true

	# delete namespaces
	sudo ip netns del srv || true
	sudo ip netns del mid || true
}

#############################################################################
#
# REMOTE FUNCTIONS
#
#

# remote_run_flent runs flent
remote_run_flent() {
	local arch="$1"
	local batch_title="$2"
	local pattern="$3"
	local dry="$4"
	# end of params

	local fl_args=""
	local bcount=0

	# cleans up after flent run
	run_flent_cleanup() {
		ns_teardown || true

		local u=$(whoami)
		local g=$(groups | cut -f1 -d " ")
		for d in $(find . -mindepth 1 -maxdepth 1 -type d); do
			sudo chown -R $u:$g "$d" || true
		done
	}

	# build flent args
	for b in $(sed -rn 's/^\[Batch::(.*)\]$/\1/p' < $BATCH_FILE); do
		if [[ $b =~ ^$arch ]]; then
			if [[ $pattern =~ "all" ]] || [[ $b =~ $pattern ]]; then
				fl_args+=" -b $b"
				((bcount++))
			fi
		fi
	done
	[[ $dry == true ]] && fl_args+=" --batch-dry-run"

	# run flent if any batches matched
	if (( bcount > 0 )); then
		trap run_flent_cleanup EXIT

		ns_setup $arch || return $?
	
		sudo flent \
			--batch-no-timestamp \
			--batch-title $batch_title \
			-B $BATCH_FILE \
			$fl_args \
			--batch-no-shuffle || return $?
	else
		echo "No matching tests to perform."
	fi
}

# remote_clear_setup is called to clear the setup on a node
remote_clear_setup() {
	for d in $(tc qdisc | awk '$3!="0:" && !x[$5]++ {print $5}'); do
		evq tc qdisc del dev $d root || true
		[[ $d != ifb* ]] && evq tc qdisc del dev $d ingress || true
	done
	for l in `ip link show | sed -rn 's/.* (ifb\S+):.*/\1/p'`; do
		evq tc qdisc del dev $l root || true
		evq ip link del dev $l || true
	done
	evq iptables -t mangle -F POSTROUTING || true
	evq ip tcp_metrics flush || true
}

# remote_setup_command is called to set up or tear down a node
remote_setup_command() {
	local command=$1; shift # setup or teardown
	local arch=$1; shift
	local net=$1; shift
	local node=$1; shift
	local cmd="$@"
	local r

	on_fail() {
		eval "PHASE=teardown; $cmd"
	}

	case $command in
		setup)
			rm -fr "$(data_dir $node)" || return $?
			mkdir -p "$(data_dir $node)" || return $?
			evs "PHASE=init; $cmd" || { r=$?; on_fail; return $r; }
			evs "PHASE=setup; $cmd" || { r=$?; on_fail; return $r; }
			evs "PHASE=show_setup; $cmd; kernel_info" || { r=$?; on_fail; return $r; }
			;;
		teardown)
			evs "PHASE=show_teardown; $cmd" || { r=$?; on_fail; return $r; }
			evs "PHASE=teardown; $cmd" || { r=$?; on_fail; return $r; }
			;;
		*)
			>&2 echo "command $command not implemented"
			on_fail
			return 1
			;;
	esac
}

# remote_plot plots all files in all directories in parallel
remote_plot() {
	local arch="$1"
	local spec="$2"

	plot_dir() {
		local pdir="$1"
		local plot="$2"
		local visitor="$3"

		if [[ -d $pdir ]]; then
			echo "Plotting directory $pdir."
			rm -f $pdir/*.png $pdir/*.svg
			local pids=()
			local f
			for f in $pdir/*.flent.gz; do
				if [[ -f $f ]]; then
					plot_file $arch "$f" $plot $visitor &
					pids+=($!)
				fi
			done
			wait_for_pids ${pids[@]} || return $?
		else
			echo "Skipping plot for non-existent directory $pdir."
		fi
	}

	local dir
	for dir in "${spec[@]}"; do
		if [[ -d $dir ]]; then
			plot_dir $dir/$arch-s1-oneflow \
				tcp_delivery_with_rtt s1_visitor || return $?
			plot_dir $dir/$arch-s2-twoflow \
				tcp_delivery_with_rtt s2_visitor || return $?
			plot_dir $dir/$arch-s3-bottleneck-shift \
				tcp_delivery_with_rtt s3_visitor || return $?
			plot_dir $dir/$arch-s4-capacity-reduction \
				tcp_delivery_with_rtt s4_visitor || return $?
			plot_dir $dir/$arch-s5-burstiness \
				tcp_delivery_with_rtt s5_visitor || return $?
			plot_dir $dir/$arch-s6-jitter \
				tcp_delivery_with_rtt s6_visitor || return $?
		fi
	done
}

# remote_push_result pushes results to the archive
remote_push_result() {
	local spec="$1"
	# end of params

	[[ $spec ]] || spec="$BATCH-*"

	echo "Pushing $spec to $PUSH_RSYNC_DEST"
	rsync -rt --ignore-missing-args \
		"$PUSH_RSYNC_ARGS" \
		$spec \
		"$PUSH_RSYNC_DEST"
}

# remote_clean removes result directories
remote_clean() {
	rm -fr $BATCH_OUT_SPEC
}

# remote_list lists result directories
remote_list() {
	local dir
	for dir in $BATCH-*; do
		[[ -d $dir ]] && echo $dir
	done
}

# remote_hello emits message for testing
remote_hello() {
	echo Hello from fl on $(hostname)!
}


#############################################################################
#
# FLENT HARNESS ENTRY POINT FUNCTIONS
#
#

# flent_clear is the flent hook for clearing the setup
flent_clear() {
	local arch=$1
	local net=$2
	# end of params

	# clear all ssh dests for phys, or all namespaces for netns
	local pids=()
	case $net in
		phys)
			local d
			for d in "${CLEAR_SSH_DESTS[@]}"; do
				fl_ssh $d true false remote_clear_setup &
				pids+=($!)
			done
			;;
		ns)
			local n
			for n in "${CLEAR_NODES[@]}"; do
				fl_node $arch $net $n remote_clear_setup &
				pids+=($!)
			done
			;;
		*)
			echo "unknown net: $net"
			return -1
	esac

	wait_for_pids ${pids[@]}
}

# flent_setup is the flent hook for node setup
flent_setup() {
	flent_setup_teardown setup "$@"
}

# flent_teardown is the flent hook for node teardown
flent_teardown() {
	flent_setup_teardown teardown "$@"
}

# flent_setup_teardown implements the flent setup and teardown hooks
flent_setup_teardown() {
	local command=$1; shift # setup|teardown
	local arch=$1; shift
	local net=$1; shift
	local data_filename="$1"; shift
	local end=$(( $# / 2 ))
	# end of params

	# log_file returns the log file name for a node
	log_file() {
		echo "$(log_dir $1)/$1.log"
	}

	# execute commands for each node in parallel
	local nodes=()
	local pids=()
	local i
	local n
	local c
	for (( i = 0; i < $end; i++ )); do
		n=$1; shift
		c="$1"; shift
		rm -fr "$(log_dir $n)" || return $?
		mkdir -p "$(log_dir $n)" || return $?
		(
			local r
			fl_node $arch $net $n \
				remote_setup_command $command $arch $net $n $(printf %q "$c") &> $(log_file $n)
			r=$?
			if (( r != 0 )); then
				>&2 echo "remote_setup_command failed, arch:$arch, node:$n, status:$r"
				>&2 echo "failed command: \"$command\""
			fi
			exit $r
		) &
		nodes+=($n)
		pids+=($!)
	done

	# wait for setup pids
	local errs
	wait_for_pids ${pids[@]}
	errs=$?

	# concatenate output from each node into one file for the command
	(
		for n in ${nodes[@]}; do
			echo $n
			echo "${n//?/-}"
			echo
			cat $(log_file $n)
			echo
			rm $(log_file $n)
			rmdir "$(log_dir $n)"
		done
	) 2>&1 | tee "${data_filename}.$command.log"

	return $errs
}

# flent_process is the flent hook for processing results
flent_process() {
	local arch=$1; shift
	local net=$1; shift
	local fname="$1"; shift # data filename
	local end=$(( $# / 2 ))
	# end of params

	# data filename base without extension
	local fbase
	fbase=$(basename $fname)
	fbase="${fbase%.*}"

	(
		# pull output data files from node
		local cmds=()
		local n
		local i
		for (( i = 0; i < $end; i++ )); do
			n=$1; shift
			cmds+=("$1"); shift
			fl_node_pull $arch $net $n $(data_dir $n) $(dirname $fname) || true
		done

		# prepend standard prefix to output files without it
		local f
		local b
		for f in $(dirname $fname)/*; do
			b=$(basename $f)
			if [[ $b != batch-* ]]; then
				mv "$f" "$(dirname $fname)/$fbase.$b" || exit 1
			fi
		done

		# run process hooks serially in case hooks depend on one another
		local c
		for c in "${cmds[@]}"; do
			eval "PHASE=process; $c" || exit 1
		done
	) 2>&1 | tee "$(dirname $fname)/$fbase.process.log"
}


#############################################################################
#
# HARNESS FUNCTIONS AND HOOKS
#
#

# tcp_metrics flushes and displays ip tcp_metrics
tcp_metrics() {
	case $PHASE in
	init|teardown)
		evq ip tcp_metrics flush || return
		;;
	show*)
		ev ip tcp_metrics show || return
		;;
	esac
}

# run_tcpdump runs tcpdump on specified interfaces
run_tcpdump() {
	local dir=bidir
	local params

	# parse args
	local a
	while true; do
		a="$1"
		shift
		case $a in
			bidir|left|right)
				dir=$a
				shift
				;;
			*)
				params="$@"
				break
				;;
		esac
	done

	killpids() {
		shopt -s nullglob
		local f
		for f in $(data_dir $node)/*.pid; do
			local pid=$(cat $f)
			kill $pid &> /dev/null || true
			while kill -0 $pid 2> /dev/null; do sleep 0.2; done;
			rm -f "$f"
		done
		shopt -u nullglob
	}

	case $PHASE in
		setup)
			killpids
			local b
			local dev
			for dev in $(node_devs $arch $net $node $dir); do
				b="$(data_dir $node)/tcpdump_${node}_$dev"
				nohup tcpdump -i $dev -n -G 120 -W 1 -s 128 -w "$b.pcap" $params &> "$b.log" &
				echo $! > "$b.pid"
			done
			;;
		init|teardown)
			killpids
			;;
	esac
}

# kernel_info cats any kernel info recorded by build process
kernel_info() {
	case $PHASE in
	show_setup)
		ev uname -a
		cat /boot/info-$(uname -r).txt || true
		;;
	esac
}

# run_scetrace runs scetrace on any pcaps
run_scetrace() {
	local dir="$1"

	case $PHASE in
	process)
		if ! type scetrace &> /dev/null; then
			echo "+ scetrace: not found"
			return
		fi
	
		shopt -s nullglob
		for f in $dir/*.pcap; do
			local j="${f%.pcap}.json"
			if ! [ -f "$j" ]; then
				ev scetrace -r \"$f\" \> \"$j\"
			fi
		done
		shopt -u nullglob
	esac
}

# compress compresses pcaps and log files
compress() {
	local dir="$1"

	case $PHASE in
	process)
		if type parallel &> /dev/null; then
			parallel $COMPRESS ::: $dir/*.pcap $dir/*.debug.log
		else
			$COMPRESS $dir/*.pcap $dir/*.debug.log
		fi
	esac
}

# qdisc configures qdiscs
qdisc() {
	# parse params in loop
	local ingress
	local dir=bidir
	local qdisc_type
	local after
	local htb_rate
	local ingress_flowid="1:1"
	local idev
	local a
	while true; do
		a="$1"
		shift
		case $a in
			root|root-tree)
				qdisc_type=$a
				break
				;;
			htb)
				qdisc_type=htb
				htb_rate=$1
				shift
				break
				;;
			ingress)
				ingress=true
				;;
			ingress-flowid)
				ingress_flowid=$1
				shift
				;;
			bidir|left|right)
				dir=$a
				;;
			after)
				after=$1; shift
				;;
			*)
				>&2 echo "unrecognized qdisc keyword: $a"
				return 1
				;;
		esac
	done
	# end of params

	# select tc
	local tc
	tc=$(arch_tc $arch)
	local idev
	local qdev

	for dev in $(node_devs $arch $net $node $dir); do
		if [[ $ingress ]]; then
			idev=$(ifb $dev)
			qdev=$idev
		else
			qdev=$dev
		fi

		case $PHASE in
		setup)
			if [[ $ingress ]]; then
				modprobe ifb || return $?
				evq ip link add dev $idev type ifb || return $?
			fi

			case $qdisc_type in
			root)
				if ! [[ $after ]]; then
					ev $tc qdisc add dev $qdev root handle 1: $@ || return $?
				else
					local dlog
					local p="$@"
					local ch_op

					dlog="$(data_dir $node)/${node}_${qdev}_root_after_${after}s.log" || \
						return $?

					nohup bash -x -s <<- EndOfAfterRoot &> $dlog &
						set -e
						root_qdisc() {
							tc qdisc show dev $qdev | head -1 | awk '{print \$2}'
						}
						root_handle() {
							tc qdisc show dev $qdev | head -1 | awk '{print \$3}'
						}
						sleep $after
						rh=\$(root_handle)
						if [[ \$(root_qdisc) == $1 ]]; then
							$tc qdisc change dev $qdev handle \$rh root $p
						else
							$tc qdisc replace dev $qdev root $p
						fi
					EndOfAfterRoot
					echo $! > "$dlog.pid" || return $?
				fi
				;;
			htb)
				if ! [[ $after ]]; then
					ev $tc qdisc add dev $qdev handle 1: root htb default 1 || return $?
					ev $tc class add dev $qdev parent 1: classid 1:1 \
						htb rate $htb_rate ceil $htb_rate || return $?
					ev $tc qdisc add dev $qdev parent 1:1 $@ || return $?
				else
					local dlog
					dlog="$(data_dir $node)/${node}_${qdev}_htb_after_${after}s.log" \
						|| return $?
					local p="$@"

					nohup bash -x -s <<- EndOfAfterHTB &> $dlog &
						set -e
						root_qdisc() {
							tc qdisc show dev $qdev | head -1 | awk '{print \$2}'
						}
						root_handle() {
							tc qdisc show dev $qdev | head -1 | awk '{print \$3}'
						}
						child_qdisc() {
							local n=\$1
							# end of params
					
							tc qdisc show dev $qdev | sed "\$((n+1))q;d" | awk '{print \$2}'
						}
						sleep $after
						if [[ \$(root_qdisc) == htb ]]; then
							$tc class change dev $qdev parent 1: classid 1:1 \
								htb rate $htb_rate ceil $htb_rate
							if test -n "$p"; then
								if [[ \$(child_qdisc 1) == "$1" ]]; then
									ch_op=change
								else
									ch_op=replace
								fi
								$tc qdisc \$ch_op dev $qdev parent 1:1 $p
							fi
						else
							$tc qdisc replace dev $qdev root htb default 1
							rh=\$(root_handle)
							$tc class add dev $qdev parent \$rh classid \${rh}1 \
								htb rate $htb_rate ceil $htb_rate
							$tc qdisc add dev $qdev parent \${rh}1 $@
						fi
					EndOfAfterHTB
					echo $! > "$dlog.pid" || return $?
				fi
				;;
			root-tree)
				ev $tc qdisc add dev $qdev root handle 1: $1 || return $?
				local m=10
				local i
				for (( i=2; i<=$#; i++ )); do
					ev $tc qdisc add dev $qdev parent 1:1 handle $m:1 ${!i} || return $?
					((m++))
				done
				;;
			esac

			if [[ $ingress ]]; then
				evq $tc qdisc add dev $dev handle ffff: ingress || return $?
				evq ip link set $idev up || return $?
				evq $tc filter add dev $dev parent ffff: protocol all \
					prio 10 u32 match u32 0 0 flowid $ingress_flowid \
					action mirred egress redirect dev $idev || return $?
			fi
			;;
		init|teardown)
			if [[ $ingress ]]; then
				evq $tc qdisc del dev $dev ingress || true
				evq $tc qdisc del dev $idev root || true
				evq ip link del dev $idev || true
			else
				evq $tc qdisc del dev $dev root || true
			fi
			;;
		show*)
			ev $tc -s -d qdisc show dev $qdev || true
			ev $tc -s -d class show dev $qdev || true
			;;
		esac
	done
}

# set_tos adds a rule to set the tos value for all packets on an interface
set_tos() {
	local ifaces="$1"; shift
	local tos="$1"
	local args="-o $i -p tcp -m tcp ! --syn -j TOS --set-tos $tos"

	for i in $(split $ifaces); do
		case $PHASE in
		setup)
			evq iptables -t mangle -I POSTROUTING $args || return $?
			;;
		init|teardown)
			evq iptables -t mangle -D POSTROUTING $args || true
			;;
		show*)
			ev iptables -t mangle -L POSTROUTING -n || return $?
			;;
		esac
	done
}

# dscp_to_tos adds an iptables rule to change a dscp to tos value
dscp_to_tos() {
	local ifaces="$1"; shift
	local dscp="$1"; shift
	local tos="$1"; shift
	local args="-o $i -p tcp -m tcp ! --syn -m dscp --dscp $dscp -j TOS --set-tos $tos"

	for i in $(split $ifaces); do
		case $PHASE in
		setup)
			evq iptables -t mangle -I POSTROUTING $args || return $?
			;;
		init|teardown)
			evq iptables -t mangle -D POSTROUTING $args || true
			;;
		show*)
			ev iptables -t mangle -L POSTROUTING -n || return $?
			;;
		esac
	done
}


#############################################################################
#
# CLI FUNCTIONS
#
#

# clean command removes non-tagged test result directories
cli_clean() {
	local what=$1
	# end of params

	clean_clients() {
		local pids=()
		local d
		for d in "${CLIENTS_SSH[@]}"; do
			fl_ssh $d false false remote_clean &
			pids+=($!)
		done
		wait_for_pids ${pids[@]}
	}

	clean_archive() {
		ssh $PUSH_SSH_ARGS $PUSH_SSH_DEST cd $ARCHIVE_DIR\; rm -fr $BATCH_OUT_SPEC
	}

	clean_local() {
		remote_clean
	}

	case $what in
		clients)
			clean_clients
			;;
		all)
			clean_clients
			clean_archive
			clean_local
			;;
		archive)
			clean_archive
			;;
		local)
			clean_local
			;;
		"")
			>&2 echo "clean requires an argument: local, clients, archive or all"
			return 1
			;;
		*)
			>&2 echo "can't clean $1 (just local, clients, archive or all)"
			return 1
			;;
	esac
}

# list command lists results
cli_list() {
	local d
	for d in "${CLIENTS_SSH[@]}"; do
		fl_ssh $d false false remote_list
	done
}

# browse command opens results in the browser
cli_browse() {
	local result=$1
	# end of params

	local url="$ARCHIVE_URL/$result"

	if [[ $BROWSER ]]; then
		$BROWSER "$url" &
	elif command -v xdg-open >& /dev/null; then
		xdg-open "$url" >& /dev/null
	elif [[ $OSTYPE =~ darwin ]]; then
		open -a Safari "$url"
	fi
}

# plot command generates plots
cli_plot() {
	local spec="${1:-$BATCH_OUT_SPEC}"
	# end of params

	local errs=0
	local d
	local a

	for a in "${ARCHS[@]}"; do
		d=$(node_ssh $a cli)
		fl_ssh $d false false remote_plot $a "$spec" || ((errs++))
	done

	return $errs
}

# gen_table command generates a markdown table for a results directory
cli_gen_table() {
	local scenario="$1"
	local verify="$2"
	# end of params

	if [[ ! $scenario ]]; then
		echo "The table command requires the scenario as an argument, e.g. s1."
		return 1
	fi

	local base_url="$RESULTS_URL/$RESULTS_DIR"

	emit_header() {
		local header="$1"
		echo "$header"
		header=${header//[! |]/-}
		echo "$header"
	}

  emit_row() {
		local c
		echo -n "$1"
		for c in "${@:2}"; do
			echo -n " | $c"
		done
		echo
	}

	links() {
		local arch=$1
		# end of params

		local urlv="${scenario}_${arch}_url"
		local purlv="${scenario}_${arch}_plot_url"

		echo -n "[plot](${!purlv})"
		echo -n " - [cli.pcap](${!urlv}.tcpdump_cli_cli.r.pcap.xz)"
		echo -n " - [srv.pcap](${!urlv}.tcpdump_srv_srv.l.pcap.xz)"
		echo -n " - [teardown](${!urlv}.teardown.log)"
	}

	verify_url() {
		local url="$1"
		# end of params
		if [[ $verify ]]; then
			curl -f --head "$url" >&/dev/null
			if (($? != 0)); then
				>&2 echo url $url not found
			fi
		fi
	}

	burl() {
		local arch=$1
		echo "$base_url/$arch-$sname"
	}

	# scenario 1
	s1_emit_table() {
		local sname="s1-oneflow"
		emit_header "Bandwidth | RTT | [SCE]($(burl sce)/) | [L4S]($(burl l4s)/)"
		local bw rtt
		for bw in 5 50 250; do
			for rtt in 20 80 160; do
				local s1_sce_url="$(burl sce)/batch-sce-$sname-ns-cubic-sce-twin_codel_af-${bw}Mbit-${rtt}ms"
				local s1_sce_plot_url="$(burl sce)/sce-$sname-ns-cubic-sce-twin_codel_af-${bw}Mbit-${rtt}ms_tcp_delivery_with_rtt.svg"
				local s1_l4s_url="$(burl l4s)/batch-l4s-$sname-ns-prague-dualpi2-${bw}Mbit-${rtt}ms"
				local s1_l4s_plot_url="$(burl l4s)/l4s-$sname-ns-prague-dualpi2-${bw}Mbit-${rtt}ms_tcp_delivery_with_rtt.svg"

				verify_url "$s1_sce_url.log"
				verify_url "$s1_sce_plot_url"
				verify_url "$s1_l4s_url.log"
				verify_url "$s1_l4s_plot_url"

				emit_row ${bw}Mbit \
					${rtt}ms \
					"$(links sce)" \
					"$(links l4s)"
			done
		done
	}

	# scenario 2
	s2_emit_table() {
		local sname="s2-twoflow"
		emit_header "RTT | qdisc | [SCE]($(burl sce)/)"
		local rtt qdisc
		for qdisc in codel1q codel1q\(40ms\) codel1q\(20ms\) lfq_cobalt \
			pfifo\(1000\) pfifo\(50\) pie pie\(1000p/20ms\) pie\(100p/20ms\) \
			pie\(100p/5ms\) pie\(noecn\) red\(150000\) red\(400000\) \
			twin_codel_af; do
			for rtt in 20 80 160; do
				local qdiscf=${qdisc//[\(\)\/]/_}
				local s2_sce_url="$(burl sce)/batch-sce-$sname-ns-cubic-vs-cubic-sce-${qdiscf}-${rtt}ms"
				local s2_sce_plot_url="$(burl sce)/sce-$sname-ns-cubic-vs-cubic-sce-${qdiscf}-${rtt}ms_tcp_delivery_with_rtt.svg"

				verify_url "$s2_sce_url.log"
				verify_url "$s2_sce_plot_url"

				emit_row ${rtt}ms \
					${qdisc} \
					"$(links sce)"
			done
		done

		echo

		emit_header "RTT | qdisc | [L4S]($(burl l4s)/)"
		for qdisc in codel1q codel1q\(40ms\) codel1q\(20ms\) dualpi2 \
			pfifo\(1000\) pfifo\(50\) pie pie\(1000p/20ms\) pie\(100p/20ms\) \
			pie\(100p/5ms\) pie\(noecn\) red\(150000\) red\(400000\); do
			for rtt in 20 80 160; do
				local qdiscf=${qdisc//[\(\)\/]/_}
				local s2_l4s_url="$(burl l4s)/batch-l4s-$sname-ns-cubic-vs-prague-${qdiscf}-${rtt}ms"
				local s2_l4s_plot_url="$(burl l4s)/l4s-$sname-ns-cubic-vs-prague-${qdiscf}-${rtt}ms_tcp_delivery_with_rtt.svg"
	
				verify_url "$s2_l4s_url.log"
				verify_url "$s2_l4s_plot_url"
	
				emit_row ${rtt}ms \
					${qdisc} \
					"$(links l4s)"
			done
		done
	}

	# scenario 3
	s3_emit_table() {
		local sname="s3-bottleneck-shift"
		emit_header "RTT | [SCE]($(burl sce)/) | [L4S]($(burl l4s)/)"
		local bw rtt
		bw=50
		for rtt in 20 80; do
			local s3_sce_url="$(burl sce)/batch-sce-$sname-ns-cubic-sce-${bw}Mbit-${rtt}ms"
			local s3_sce_plot_url="$(burl sce)/sce-$sname-ns-cubic-sce-${bw}Mbit-${rtt}ms_tcp_delivery_with_rtt.svg"
			local s3_l4s_url="$(burl l4s)/batch-l4s-$sname-ns-prague-${bw}Mbit-${rtt}ms"
			local s3_l4s_plot_url="$(burl l4s)/l4s-$sname-ns-prague-${bw}Mbit-${rtt}ms_tcp_delivery_with_rtt.svg"

			verify_url "$s3_sce_url.log"
			verify_url "$s3_sce_plot_url"
			verify_url "$s3_l4s_url.log"
			verify_url "$s3_l4s_plot_url"

			emit_row \
				${rtt}ms \
				"$(links sce)" \
				"$(links l4s)"
		done
	}

	# scenario 4
	s4_emit_table() {
		local sname="s4-capacity-reduction"
		emit_header "Bandwidth1 | RTT | [SCE]($(burl sce)/) | [L4S]($(burl l4s)/)"
		local bw bw1 rtt
		bw=50
		for bw1 in 40 5; do
			for rtt in 20 80; do
				local s4_sce_url="$(burl sce)/batch-sce-$sname-ns-reno-sce-${bw}Mbit-${bw1}mbit-${rtt}ms"
				local s4_sce_plot_url="$(burl sce)/sce-$sname-ns-reno-sce-${bw}Mbit-${bw1}mbit-${rtt}ms_tcp_delivery_with_rtt.svg"
				local s4_l4s_url="$(burl l4s)/batch-l4s-$sname-ns-prague-${bw}Mbit-${bw1}mbit-${rtt}ms"
				local s4_l4s_plot_url="$(burl l4s)/l4s-$sname-ns-prague-${bw}Mbit-${bw1}mbit-${rtt}ms_tcp_delivery_with_rtt.svg"
	
				verify_url "$s4_sce_url.log"
				verify_url "$s4_sce_plot_url"
				verify_url "$s4_l4s_url.log"
				verify_url "$s4_l4s_plot_url"
	
				emit_row ${bw1}Mbit \
					${rtt}ms \
					"$(links sce)" \
					"$(links l4s)"
			done
		done
	}

	# scenario 5
	s5_emit_table() {
		local sname="s5-burstiness"
		emit_header "qdisc | RTT | [SCE]($(burl sce)/)"
		local bw qdisc rtt
		bw=50
		for qdisc in cake twin_codel_af; do
			for rtt in 20 80; do
				local s5_sce_url="$(burl sce)/batch-sce-$sname-ns-cubic-sce-${qdisc}-${bw}Mbit-${rtt}ms"
				local s5_sce_plot_url="$(burl sce)/sce-$sname-ns-cubic-sce-${qdisc}-${bw}Mbit-${rtt}ms_tcp_delivery_with_rtt.svg"
	
				verify_url "$s5_sce_url.log"
				verify_url "$s5_sce_plot_url"
	
				emit_row ${qdisc} \
					${rtt}ms \
					"$(links sce)"
			done
		done

		echo

		emit_header "qdisc | RTT | [L4S]($(burl l4s)/)"
		qdisc=dualpi2
		for rtt in 20 80; do
			local s5_l4s_url="$(burl l4s)/batch-l4s-$sname-ns-prague-dualpi2-${bw}Mbit-${rtt}ms"
			local s5_l4s_plot_url="$(burl l4s)/l4s-$sname-ns-prague-dualpi2-${bw}Mbit-${rtt}ms_tcp_delivery_with_rtt.svg"

			verify_url "$s5_l4s_url.log"
			verify_url "$s5_l4s_plot_url"

			emit_row ${qdisc} \
				${rtt}ms \
				"$(links l4s)"
		done
	}

	# scenario 6
	s6_emit_table() {
		local sname="s6-jitter"
		emit_header "netem-jitter-params | RTT | [SCE]($(burl sce)/) | [L4S]($(burl l4s)/)"
		local rtt bw njp njpf
		rtt=80
		bw=50
		for njp in "2ms 1ms 10%" "4ms 2ms 10%" "10ms 5ms 10%"; do
				local njpf=${njp//[ %]/_}
				local s6_sce_url="$(burl sce)/batch-sce-$sname-ns-cubic-sce-twin_codel_af-${bw}Mbit-${rtt}ms-netem_delay_${njpf}"
				local s6_sce_plot_url="$(burl sce)/sce-$sname-ns-cubic-sce-twin_codel_af-${bw}Mbit-${rtt}ms-netem_delay_${njpf}_tcp_delivery_with_rtt.svg"
				local s6_l4s_url="$(burl l4s)/batch-l4s-$sname-ns-prague-dualpi2-${bw}Mbit-${rtt}ms-netem_delay_${njpf}"
				local s6_l4s_plot_url="$(burl l4s)/l4s-$sname-ns-prague-dualpi2-${bw}Mbit-${rtt}ms-netem_delay_${njpf}_tcp_delivery_with_rtt.svg"
	
				verify_url "$s6_sce_url.log"
				verify_url "$s6_sce_plot_url"
				verify_url "$s6_l4s_url.log"
				verify_url "$s6_l4s_plot_url"
	
				emit_row "${njp}" \
					${rtt}ms \
					"$(links sce)" \
					"$(links l4s)"
		done
	}

	# select function to run from scenario
	local sfunc="${scenario}_emit_table"
	if type -t $sfunc >&/dev/null; then
		$sfunc
	else
		echo "$scenario table not implemented"
	fi
}

# gen_readme command generates README.md from README.tpl.md
cli_gen_readme() {
	plot_url() {
		local batch_dir="$1"
		local suffix="$2"
		echo "$RESULTS_URL/$RESULTS_DIR/$batch_dir/$batch_dir-$suffix"
	}

	plot_link() {
		local text="$1"
		local batch_dir="$2"
		local suffix="$3"
		echo "[$text]($(plot_url "$2" "$3"))"
	}

	batch_url() {
		local batch_dir="$1"
		local suffix="$2"
		echo "$RESULTS_URL/$RESULTS_DIR/$batch_dir/batch-$batch_dir-$suffix"
	}

	batch_link() {
		local text="$1"
		local batch_dir="$2"
		local suffix="$3"
		echo "[$text]($(batch_url "$2" "$3"))"
	}

	plot_inline() {
		local text="$1"
		local batch_dir="$2"
		local suffix="$3"
		echo "![$text]($(plot_url "$2" "$3"))"
	}

	eval "cat << EndOfREADME
$(<README.tpl.md)
EndOfREADME
"
}

# push command pushes results to repo
cli_push() {
	local batch_title="$1"
	# end of params

	local pids=()
	local d
	for d in "${CLIENTS_SSH[@]}"; do
		fl_ssh $d false false remote_push_result $batch_title &
		pids+=($!)
	done

	wait_for_pids ${pids[@]}
}

# pull command pulls results
cli_pull() {
	local batch_title="${1:-$BATCH-????-??-?????????}"
	local pcaps="$2"
	# end of params

	pcap_arg() {
		[[ $pcaps == "-p" ]] && echo "--exclude *pcap*"
	}

	local pids=()
	local d
	for d in "${CLIENTS_SSH[@]}"; do
		rsync \
			-rtv $(pcap_arg) \
			--exclude 'README.md' \
			--exclude 'README.tpl.md' \
			--exclude 'flent.out' \
			--exclude 'config' \
			--ignore-missing-args \
			$d:$SCRIPT_DIR/$batch_title . &
		pids+=($!)
	done

	wait_for_pids ${pids[@]}
}

# run command runs flent, generates plots and pushes results
cli_run() {
	# parse options
	opts=$(getopt -o nqub -- "$@")
	if (( $? != 0 )); then
		cat <<- EndOfRunUsage >&2
		fl run [-n] [-q] [-u] pattern

		-n: noop (dry run)
		-q: don't send complete notification
		-u: push to www server

		pattern: test regex or all
		EndOfRunUsage
		return 1
	fi

	local dry=false
	local push=false
	local quiet=false
	eval set -- "$opts"
	while true; do
		case "$1" in
			-n) dry=true ;;
			-q) quiet=true ;;
			-u) push=true ;;
			--) shift
				break
				;;
		esac
		shift
	done

	local pattern="${1:-all}"
	# end of params

	# send_complete sends a pushover message after run completes
	send_complete() {
		local status=$1
		# end of params
	
		local sound
		local msg
	
		stohms() {
			date -d@$1 -u +%H:%M:%S
		}
	
		if (( status == 0 )); then
			sound=$PUSHOVER_SOUND_SUCCESS
			msg="Flent run on $(hostname) successful in $(stohms $SECONDS)!"
		else
			sound=$PUSHOVER_SOUND_FAILURE
			msg="Flent run on $(hostname) failed with status $status in $(stohms $SECONDS)."
		fi

		send_pushover $sound "$msg" || true
	}

	# run tests
	local batch_title="ect1-$(date +%Y-%m-%dT%H%M%S)"
	local r
	local d
	local a
	for a in ${ARCHS[@]}; do
		d=$(node_ssh $a cli)
		fl_ssh $d false false remote_run_flent $a $batch_title $pattern $dry
		r=$?
		if (( r != 0 )) && [[ $dry == false ]] && [[ $quiet == false ]]; then
			send_complete $r
			return $r
		fi
	done

	local errs=0
	if [[ $dry == false ]]; then
		# generate plots
		cli_plot $batch_title || ((errs++))

		# push results
		if [[ $push == true ]]; then
			cli_push $batch_title || ((errs++))
			if (( $? == 0 )); then
				cli_browse $batch_title
			else
				((errs++))
			fi
		fi

		# send notification
		[[ $quiet == false ]] && send_complete $errs
	fi

	return $errs
}

# hello command emits message for testing
cli_hello() {
	local d
	local pids=()
	local errs=0
	local p

	case $1 in
		clients)
			for d in ${CLIENTS_SSH[@]}; do
				fl_ssh $d false false remote_hello &
				pids+=($!)
			done
			wait_for_pids ${pids[@]}
			;;
		all)
			for d in ${FL_SSH[@]}; do
				fl_ssh $d false false remote_hello &
				pids+=($!)
			done
			wait_for_pids ${pids[@]}
			;;
		*)
			remote_hello
			;;
	esac
}

# pushover command sends a test pushover message
cli_pushover() {
	send_pushover $PUSHOVER_SOUND_SUCCESS "test pushover message"
}


#############################################################################
#
# COMMAND LINE INTERFACE (ONLY FOR HUMANS)
#
#

# run_cli runs the command line interface
run_cli() {
	# usage displays usage and exits
	usage() {
		cat <<- EndOfUsage >&2
		fl [-l] [-m] [-b] command
		
		-l: run locally, without updating remote hosts
		-m: run commands via ssh on management host
		-b: run commands in background
		-h: show usage
		EndOfUsage
		exit 1
	}

	# parse command line arguments
	local o
	local mgmt
	local sync=true
	local background
	mgmt=false
	background=false
	while getopts ":lmbh" o; do
		case "$o" in
			l)
				sync=false
				;;
			m)
				mgmt=true
				;;
			b)
				background=true
				;;
			*)
				usage
				;;
		esac
	done
	shift $((OPTIND-1))

	# run usage if no args
	[[ ! $@ ]] && usage

	# sync source files on hosts that need it
	local md5sum

	# only sync if md5sum of local tar changes
	md5sum=$(tar \
		-C $SOURCE_DIR \
		--exclude="./.*" \
		--exclude="$BATCH-????-??-?????????" \
		--exclude="private/*" \
		-cf - . | md5sum)
	if [[ -f .md5sum ]]; then
		[[ $(< .md5sum) == $md5sum ]] && sync=false
	fi

	# sync with rsync, if necessary
	if [[ $sync == true ]]; then
		local pids=()
		local d
		for d in "${FL_SSH[@]}"; do
			rsync \
				--exclude=".*" \
				--exclude="$BATCH-????-??-?????????" \
				-rt \
				$SOURCE_DIR $d:$SCRIPT_DIR 2>&1 | sed "s/^/$d: /" &
			pids+=($!)
		done
		wait_for_pids ${pids[@]}
		local r=$?
		if (( r == 0 )); then
			echo "$md5sum" > .md5sum
		else
			echo "unable to sync script to remote hosts, skipping"
		fi
	fi

	# run locally or remotely
	if [[ $mgmt == true ]]; then
		fl_ssh $MGMT_SSH false $background "cli_$@"
	else
		if [[ $background == true ]]; then
			eval "cli_$@" &> $SCRIPT_DIR/log.txt &
		else
			eval "cli_$@"
		fi
	fi

	return $?
}

#############################################################################
#
# MAIN
#
#

if [[ $1 =~ ^(cli|remote|flent)_ ]]; then # these prefixes run directly
	eval "$@"
elif [[ $1 =~ ^_debug_ ]]; then # _debug_ prefix for testing is stripped
	eval "${@#_debug_}"
else # regular cli
	run_cli "$@"
fi
